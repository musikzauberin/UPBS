geom_smooth(method=lm, formula=y~poly(x,2),    # add regression lines
fullrange = TRUE,   # line span full x axis
alpha = 0.1,        # increase transparency
size=0.5,
colour="red",
se=FALSE)
summaryplot5
geom_smooth(method=lm, formula=y~poly(x,2),    # add regression lines
fullrange = TRUE,   # line span full x axis
alpha = 0.1,        # increase transparency
size=0.5,
colour="grey")
summaryplot5
summaryplot5 <- summaryplot3 +
geom_smooth(method=lm, formula=y~poly(x,2),    # add regression lines
fullrange = TRUE,   # line span full x axis
alpha = 0.1,        # increase transparency
size=0.5,
colour="grey")
summaryplot5
summaryplot5 <- summaryplot3 +
geom_smooth(method=lm, formula=y~poly(x,2),    # add regression lines
fullrange = TRUE,   # line span full x axis
alpha = 0.1,        # increase transparency
size=0.5,
colour="black")
summaryplot5
summaryplot5 <- summaryplot3 +
geom_smooth(method=lm, formula=y~poly(x,2),    # add regression lines
fullrange = TRUE,   # line span full x axis
alpha = 0.1,        # increase transparency
size=0.5,           # thinner lines
colour="black")     # colour fitted lines black
summaryplot5
ggsave('../Results/Celegans_summary.pdf', height=5, width=10)
LinearModel<-function(md){lm(rel_expression~time_min,data=md)}
require(plyr)
require(scales)
str(plotData)
LinearModel<-function(plotData){lm(RelativeExpression~time_min,data=plotData)}
LinearModel<-function(plotData){lm(RelativeExpression~time_min,data=plotData)}
#using plyr iterate over all genes
AllLinearModel<-dlply(plotData,.(Genes), LinearModel)
AllLinearModels<-dlply(plotData,.(Genes), LinearModel) # apply function LinearModel to plotData, categorised by genes
?lm
LinearCoeffs = ldply(AllLinearModels, coefficients)
head(LinearCoeffs)
LinearCoeffs = ldply(AllLinearModels, coef)
head(LinearCoeffs)
AllLinearModels
LinearCoeffs = ldply(AllLinearModels, coef)
head(LinearCoeffs)
require(plyr)
require(scales)
str(plotData)
#set the basic model
LinearModel<-function(plotData){lm(RelativeExpression ~ time_min, data = plotData)}
# function(input) {what to do with input/ linear model relative exp against time, using input data}
# using plyr to iterate over all genes
AllLinearModels<-dlply(plotData,.(Genes), LinearModel) # apply function LinearModel to plotData, categorised by genes
head(LinearCoeffs)
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, df.residual)
Linear = ldply(AllLinearModels, df.residual)
Linear
Linear = ldply(AllLinearModels, model)
anova(AllLinearModels)
summary(AllLinearModels)
?ldply
LinearCoeffs = ldply(AllLinearModels, coefficients, .id = c("gene", "intercept", "linear"))
LinearCoeffs
colnames(LinearCoeffs) <- c("gene", "intercept", "linear")
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, coefficients, .id = c("gene", "intercept", "linear"))
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, coefficients, id = c("gene", "intercept", "linear"))
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, id = c("gene", "intercept", "linear"), coefficients)
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, coefficients, variable.id = c("gene", "intercept", "linear"))
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, coefficients, variables.id = c("gene", "intercept", "linear"))
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, coefficients, names = c("gene", "intercept", "linear"))
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, coefficients, data.id = c("gene", "intercept", "linear"))
LinearCoeffs
LinearCoeffs <- LinearCoeffs[order(-LinearCoeffs $linear),]
head(LinearCoeffs)
LinearCoeffs <- LinearCoeffs[order(-LinearCoeffs$linear),]
head(LinearCoeffs)
LinearCoeffs <- LinearCoeffs[order(-LinearCoeffs$linear),]
head(LinearCoeffs)
LinearCoeffs <- LinearCoeffs[order(-(LinearCoeffs$linear)),]
head(LinearCoeffs)
colnames(LinearCoeffs) <- c("gene", "intercept", "linear")
#sort by the linear coefficient
LinearCoeffs <- LinearCoeffs[order(-LinearCoeffs$linear),]
head(LinearCoeffs)
?lm
LinearCoeffs = ldply(AllLinearModels, anova)
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, summary)
LinearCoeffs
LinearCoeffs = ldply(AllLinearModels, summary)
AllLinearModels
AllLinearModels<-dlply(AllLinearModels,.(Genes), summary)
LinearCoeffs <- LinearCoeffs[order(-LinearCoeffs$linear),]
head(LinearCoeffs)
AllLinearModels<-dlply(AllLinearModels,.(gene), summary)
str(AllLinearModels)
LinearCoeffs = ldply(AllLinearModels, coefficients)
# label columns
colnames(LinearCoeffs) <- c("gene", "intercept", "linear")
AllLinearModels
AllLinearModels<-dlply(plotData,.(Genes), summary(LinearModel)
)
AllLinearModels<-dlply(plotData,.(Genes), summary(LinearModel))
LinearModel<-function(plotData){lm(RelativeExpression ~ time_min, data = plotData)}
LinearModel<-function(plotData){summary(lm(RelativeExpression ~ time_min), data = plotData)}
AllLinearModels<-dlply(plotData,.(Genes), LinearModel) # apply function LinearModel to plotData, categorised by genes
head(plotData)
LinearModel<-function(plotData){summary(lm(plotData$RelativeExpression ~ plotData$time_min), data = plotData)}
# function(input) {what to do with input/ linear model relative exp against time, using input data}
# using plyr to iterate over all genes
AllLinearModels<-dlply(plotData,.(Genes), LinearModel) # apply function LinearModel to plotData, categorised by genes
AllLinearModels
?lm
Residuals = ldply(AllLinearModels, df.residual)
Residuals
Residuals = ldply(AllLinearModels, df.residual)
require(plyr)
require(scales)
str(plotData)
#set the basic model
LinearModel<-function(plotData){lm(RelativeExpression ~ time_min, data = plotData)}
# function(input) {what to do with input/ linear model relative exp against time, using input data}
# using plyr to iterate over all genes
AllLinearModels<-dlply(plotData,.(Genes), LinearModel) # apply function LinearModel to plotData, categorised by genes
AllLinearModels
# Get all linear coefficients (the slopes)
LinearCoeffs = ldply(AllLinearModels, coefficients)
# label columns
colnames(LinearCoeffs) <- c("gene", "intercept", "linear")
# sort by modulus of linear coefficient
LinearCoeffs <- LinearCoeffs[order(-LinearCoeffs$linear),]
head(LinearCoeffs)
LinearCoeffs
LinearCoeffs <- LinearCoeffs[order(-LinearCoeffs$linear),]
LinearCoeffs
Residuals = ldply(AllLinearModels, df.residual)
Residuals
LinearModel<-function(plotData){summary(lm(plotData$RelativeExpression ~ plotData$time_min))}
LinearModel
ModelSummary<-function(plotData){summary(lm(plotData$RelativeExpression ~ plotData$time_min))}
AllModelSummary<-dlply(plotData,.(Genes), ModelSummary) # apply function to plotData, in this case data = plotData, categorised by genes
AllModelSummary
?summary
LinearCoeffs = ldply(AllModelSummary, adjusted)
LinearCoeffs
LinearCoeffs = ldply(AllModelSummary, adjusted)
LinearCoeffs = ldply(AllModelSummary, adj.r.squared)
LinearCoeffs = ldply(AllModelSummary, r.squared)
LinearCoeffs = ldply(AllModelSummary, fstatistic)
AllModelSummary
head(AllModelSummary)
LinearCoeffs = ldply(AllModelSummary, call(fstatistic))
LinearCoeffs = dlply(AllModelSummary, call(fstatistic))
LinearCoeffs = dlply(AllModelSummary, fstatistic)
ModelSummary<-function(data){summary(lm(data$RelativeExpression ~ data$time_min)), data=data}
ModelSummary<-function(data){summary(lm(data$RelativeExpression ~ data$time_min), data=data)}
# function(input) {what to do with input/ linear model relative exp against time, using input data}
# using plyr to iterate over all genes
AllModelSummary<-dlply(plotData,.(Genes), ModelSummary) # apply function to plotData, in this case data = plotData, categorised by genes
AllModelSummary
LinearCoeffs = ldply(AllModelSummary, fstatistic)
LinearCoeffs = ldply(AllModelSummary, coeff)
LinearCoeffs = ldply(AllModelSummary, coef)
LinearCoeffs
LinearCoeffs = ldply(AllModelSummary, coefficients)
LinearCoeffs
Coeffs = ldply(AllModelSummary, coefficients)
Coeffs
something <- dlply(AllModelSummary, call(fstatistic))
something <- dlply(AllModelSummary, call(.fstatistic))
something <- dlply(AllModelSummary, fstatistic)
something <- ldply(AllModelSummary, fstatistic)
AllModelSummary
AllModelSummary$adj.r.squared
AllModelSummary<-dlply(plotData,.(Genes), ModelSummary$adj.r.squared) # apply function to plotData, in this case data = plotData, categorised by genes
AllModelSummary
AllModelSummary<-dlply(plotData,.(Genes), ModelSummary$adj.r.squared) # apply function to plotData, in this case data = plotData, categorised by genes
AllModelSummary<-dlply(plotData,.(Genes), ModelSummary) # apply function to plotData, in this case data = plotData, categorised by genes
AllModelSummary
adjRvalues<-function(data){summary(lm(data$RelativeExpression ~ data$time_min)$adj.r.squared, data=data)}
adjR<-function(data){summary(lm(data$RelativeExpression ~ data$time_min)$adj.r.squared, data=data)}
adjRvalues<-dlply(plotData,.(Genes), adjR)
adjR<-function(data){summary(lm(data$RelativeExpression ~ data$time_min)$adj.r.squared, data=data)}
adjRvalues<-dlply(plotData,.(Genes), adjR)
adjRvalues
adjR<-function(data){summary(lm(data$RelativeExpression ~ data$time_min), data=data)$adj.r.squared}
adjRvalues<-dlply(plotData,.(Genes), adjR)
adjRvalues
adjRvalues[,1]
adjRvalues[1,]
adjRvalues[1]
adjRvalues[,]
adjRvalues[,1]
adjRvalues[1]
adjRvalues
adjRvalues
LinearCoeffs
colnames(adjRvalues) <- c("adjR")
str(adjRvalues)
ModelSummary<-function(input){summary(lm(input$RelativeExpression ~ input$time_min), data=input)}
# function(input) {what to do with input/ linear model relative exp against time, using input data}
# using plyr to iterate over all genes
AllModelSummary<-dlply(plotData,.(Genes), ModelSummary) # apply function to plotData, in this case data = plotData, categorised by genes
AllModelSummary
AllModelSummary<-dlply(plotData,.(Genes), ModelSummary) # apply function to plotData, in this case input = plotData, categorised by genes
AllModelSummary
# shows all summaries of models
# show bare coefficients
Coeffs = ldply(AllModelSummary, coefficients)
Coeffs
# find only adjusted r values
adjR<-function(data){summary(lm(data$RelativeExpression ~ data$time_min), data=data)$adj.r.squared}
adjRvalues<-dlply(plotData,.(Genes), adjR)
str(adjRvalues)
## Can we improve adjusted R values with quadratic models?
## Model all gene expression with quadratic models
str(as.numeric(as.character(adjRvalues))
)
hi <- str(as.numeric(as.character(adjRvalues))
)
hi
hi <- as.numeric(as.character(adjRvalues))
hi
allRvalues <- as.numeric(as.character(adjRvalues))
Rvalues
allRvalues <- as.numeric(as.character(adjRvalues))
allRvalues
?summary.lm
?summary.lm
QuadModel<-function(input){lm(RelativeExpression ~ time_min + I(time_min^2), data = input)}
AllQuadModel<-dlply(plotData,.(Genes),quadmodel)
AllQuadModel<-dlply(plotData, .(Genes), QuadModel)
QuadCoeff = ldply(AllQuadModel,coef)
QuadCoeff = ldply(AllQuadModel,coef)
colnames(QuadCoeff) <- c("year", "intercept", "linear", "quad")
QuadCoeff<- QuadCoeff[order(+QuadCoeff$quad),]
head(QuadCoeff)
QuadCoeff<- QuadCoeff[order(QuadCoeff$quad),]
head(QuadCoeff)
adjR<-function(data){summary(lm(RelativeExpression ~ time_min + I(time_min^2)), data=data)$adj.r.squared}
adjRvalues<-dlply(plotData,.(Genes), adjR)
adjR<-function(input){summary(lm(input$RelativeExpression ~ input$time_min + I(input$time_min^2)), data=input)$adj.r.squared}
adjRvalues<-dlply(plotData,.(Genes), adjR)
allRvalues <- as.numeric(as.character(adjRvalues))
allRvalues
adjRvalues
allRvalues
adjRvalues
adjR<-function(data){summary(lm(data$RelativeExpression ~ data$time_min), data=data)$adj.r.squared}
adjRvalues<-dlply(plotData,.(Genes), adjR)
adjRvalues
# Loading libraries
library(cluster)
library(gplots)
library(gtools)
library(gdata)
library(caTools)
library(bitops)
library(RColorBrewer)
# Make a distance matrix:  specify the columns that the data are in by mydata[,1:lastcolumnnumber]. This will depend on how many genes you have in your interaction network.
head(tempData)
head(tempData)
DistanceMatrix<-dist(tempData[,2:ncol(tempData)], method = "euclidean", diag = TRUE, upper = TRUE, p = 2)
list(DistanceMatrix)
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col=bluered(25),
trace="none",
density.info="none",
mar=c(5,5),
symkey=TRUE,
dendrogram="column",
labRow=plotData$time_min,
scale=c("col"),
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="complete"))
dir("../Results")
# create your own colour palette
my_palette <- colorRampPalette(c("blue", "white", "red"))(n = 299)
# my_palette <- colorRampPalette(c("dark green", "yellow", "red"))(n = 299)
# Make the two-way cluster and heatmap.  Again specify the columns that your data are in. Also specify the label.
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col=my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
cexRow = 1.2,
cexCol = 1.2, #0.8 for many genes
offsetCol = 0,
colsep=1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=d$time_min,
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(dm) hclust((dm),method="ward.D2"))
?hclust
pdf(file = "../Results/Celegans_heatmap", width=11, height=8)
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col=my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
cexRow = 1.2,
cexCol = 1.2, #0.8 for many genes
offsetCol = 0,
colsep=1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
dev.off()
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col=my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
cexRow = 1.2,
cexCol = 1.2, #0.8 for many genes
offsetCol = 0,
colsep=1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col=my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
cexRow = 1.2,
cexCol = 1.2, #0.8 for many genes
offsetCol = 0,
colsep=1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
dev.off()
my_palette <- colorRampPalette(c("blue", "white", "red"))(n = 299)
head(tempData)
DistanceMatrix<-dist(tempData[,2:ncol(tempData)], method = "euclidean", diag = TRUE, upper = TRUE, p = 2)
# see that you've made your datamatrix.  You should see a grid of pairwise distances.
list(DistanceMatrix)
# create your own colour palette
my_palette <- colorRampPalette(c("blue", "white", "red"))(n = 299)
# my_palette <- colorRampPalette(c("dark green", "yellow", "red"))(n = 299)
# Make the two-way cluster and heatmap.  Again specify the columns that your data are in. Also specify the label.
pdf(file = "../Results/Celegans_heatmap", width=11, height=8)
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col=my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
cexRow = 1.2,
cexCol = 1.2, #0.8 for many genes
offsetCol = 0,
colsep=1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
dev.off()
my_palette <- colorRampPalette(c("dark green", "yellow", "red"))(n = 299)
# Make the two-way cluster and heatmap.  Again specify the columns that your data are in. Also specify the label.
pdf(file = "../Results/Celegans_heatmap", width=11, height=8)
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col = my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
cexRow = 1.2,
cexCol = 1.2,
offsetCol = 0,
colsep = 1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
dev.off()
dir("../Results") # check if plot has been saved
?heatmap.2
# Make the two-way cluster and heatmap.  Again specify the columns that your data are in. Also specify the label.
pdf(file = "../Results/Celegans_heatmap", width=11, height=8)
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col = my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
# for more info check out ?heatmap.2
dev.off()
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col = my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
colsep = 1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
pdf(file = "../Results/Celegans_heatmap", width=11, height=8)
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col = my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
colsep = 1:55,
sepcolor='white', sepwidth=0.05,
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45,
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
# for more info check out ?heatmap.2
dev.off()
pdf(file = "../Results/Celegans_heatmap", width=11, height=8)
heatmap<-heatmap.2(data.matrix(tempData[,2:ncol(tempData)]),
col = my_palette,
main = "C. elegans gene expression", # heat map title
ylab = "Time/min",
xlab = "Genes",
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
margins =c(5,5),      # widens margins around plot
colsep = 1:55, sepcolor='white', sepwidth=0.05, # create white separation bet cols
symkey=TRUE,
dendrogram="column",
labRow=tempData$time_min, # rows in heatmap refer to time
scale=c("col"),
srtCol = 45, # rotate labels
Rowv=FALSE,
hclustfun=function(DistanceMatrix) hclust((DistanceMatrix),method="ward.D2"))
# for more info check out ?heatmap.2
dev.off()
